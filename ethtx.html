<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>ETH Staking Transfer Optimisation</title>
<style>
  :root { --bg:#0b0c10; --card:#121319; --muted:#7f8c99; --fg:#e8ecf1; --accent:#5ad6a3; --accent2:#9af0ca; --border:#232632; }

  /* Fix overflow: make sizing predictable everywhere */
  *, *::before, *::after { box-sizing: border-box; }

  /* Base */
  body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
  .container { max-width: 1280px; margin: 32px auto; padding: 0 16px; } /* widened */
  h1 { font-size: 24px; margin: 0 0 16px; }
  h3 { margin: 0 0 12px; }
  p.desc { color: var(--muted); margin-top: 0; }
  .grid { display: grid; gap: 12px; grid-template-columns: repeat(12, 1fr); }
  /* Allow grid children to shrink so inputs don't push outside */
  .grid > * { min-width: 0; }
  .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 16px; }
  .span-12 { grid-column: span 12; }
  .span-6 { grid-column: span 6; }
  .span-4 { grid-column: span 4; }
  .span-3 { grid-column: span 3; }
  .span-2 { grid-column: span 2; }

  label { display:block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
  input {
    width:100%; max-width:100%;
    padding:12px 14px;
    border-radius:10px; border:1px solid var(--border);
    background:#0f1016; color:var(--fg);
  }
  .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }

  /* Button + hover animation */
  .btn {
    appearance: none; background: var(--accent); color:#042318; border:none;
    border-radius: 12px; padding: 12px 16px; font-weight: 700; cursor: pointer;
    transition: transform .15s ease, box-shadow .25s ease, filter .25s ease;
    box-shadow: 0 0 0 rgba(90,214,163,0);
  }
  .btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 10px 24px rgba(90,214,163,.25), 0 0 0 1px rgba(90,214,163,.30) inset;
    filter: brightness(1.03);
  }
  .btn:active { transform: translateY(0); box-shadow: 0 6px 16px rgba(90,214,163,.18); }
  .btn:disabled { opacity:.6; cursor:not-allowed; }

  .pill { display:inline-block; background:#0f1016; border:1px solid var(--border); padding:6px 10px; border-radius:999px; font-size:12px; color: var(--muted); }
  .muted { color: var(--muted); }

  /* Desktop tables */
  .table-wrap { width: 100%; }
  .table { width:100%; border-collapse: collapse; font-size: 13px; table-layout:auto; }
  .table th, .table td { padding: 12px 14px; border-bottom: 1px solid var(--border); text-align: left; vertical-align: top; }
  .table th { color: var(--muted); font-weight:600; }
  .nowrap { white-space: nowrap; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-variant-numeric: tabular-nums; -webkit-font-feature-settings: "tnum" 1, "lnum" 1; font-feature-settings: "tnum" 1, "lnum" 1; white-space: nowrap; }
  .num { text-align: right; }

  /* Mobile “cards” — no horizontal scroll */
  .list { display: grid; grid-template-columns: 1fr; gap: 10px; }
  .item { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 12px; }
  .item h4 { margin: 0 0 6px; font-size: 14px; }
  .kv { display:grid; grid-template-columns: auto 1fr; gap: 6px 10px; }
  .kv div { padding: 4px 0; }
  .k { color: var(--muted); }
  .v { text-align: right; }
  .v .mono { white-space: nowrap; }

  .subhead { margin: 10px 0 6px; color: var(--muted); font-size: 12px; }
  footer { margin: 24px 0; color: var(--muted); font-size: 12px; }

  /* Responsive: stack inputs on mobile */
  @media (max-width: 900px) {
    .span-6, .span-4, .span-3, .span-2 { grid-column: span 12; }
  }

  /* Kill tables on small screens; use cards instead */
  @media (max-width: 820px) { .table-wrap { display:none; } }
  @media (min-width: 821px) { .cards { display:none; } }

  /* Slightly smaller type in very tight spaces (iPhone landscape is ~736–812px CSS px) */
  @media (max-width: 820px) {
    body { font-size: 15px; }
    h1 { font-size: 20px; }
    .item { padding: 12px; }
    .kv { gap: 4px 8px; }
  }

  /* Loading overlay */
  .loader.hidden { display: none; }
  .loader {
    position: fixed; inset: 0; display: grid; place-items: center;
    background: rgba(11,12,16,0.55); backdrop-filter: blur(2px);
    z-index: 9999;
  }
  .spinner {
    width: 78px; height: 78px; position: relative; margin-bottom: 12px;
  }
  .spinner::before, .spinner::after {
    content: ""; position: absolute; inset: 0; border-radius: 50%;
    border: 3px solid transparent; border-top-color: var(--accent);
    animation: spin 1s linear infinite;
  }
  .spinner::after {
    inset: 8px; border-top-color: var(--accent2); animation-duration: 1.6s;
  }
  .loader p { color: var(--muted); font-size: 12px; letter-spacing: .02em; }
  @keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>
<div class="container">
  <h1>ETH Staking Transfer Optimisation</h1>
  <p class="desc">Enter 4 source wallet <b>liquid</b> balances, 3 staking wallet <b>liquid</b> balances, and 3 staking wallet <b>staked total balances</b>. <br><br> This software maximizes validators, minimizes transactions, and prefers topping up the wallet with the smallest <b>staked balance</b>. Each transfer carries a buffer (for tx fees), we show min/max leftover buffers after fees.</p>

  <div class="grid">
    <div class="card span-6">
      <h3>Source Wallets (4)</h3>
      <div class="grid">
        <div class="span-3"><label>Wallet 1</label><input id="src1" type="number" step="0.00000001" value="10"></div>
        <div class="span-3"><label>Wallet 2</label><input id="src2" type="number" step="0.00000001" value="50"></div>
        <div class="span-3"><label>Wallet 3</label><input id="src3" type="number" step="0.00000001" value="20"></div>
        <div class="span-3"><label>Wallet 4</label><input id="src4" type="number" step="0.00000001" value="1"></div>
      </div>
    </div>

    <div class="card span-6">
      <h3>Staking Wallets (3) — Liquid</h3>
      <div class="grid">
        <div class="span-4"><label>Staking 1 Liquid</label><input id="stkL1" type="number" step="0.00000001" value="20"></div>
        <div class="span-4"><label>Staking 2 Liquid</label><input id="stkL2" type="number" step="0.00000001" value="31"></div>
        <div class="span-4"><label>Staking 2 Liquid</label><input id="stkL3" type="number" step="0.00000001" value="40"></div>
      </div>
    </div>

    <div class="card span-6">
      <h3>Staking Wallets (3) — Staked Totals (balancing)</h3>
      <div class="grid">
        <div class="span-4"><label>Staking 1 Total</label><input id="stkS1" type="number" step="0.00000001" value="10000"></div>
        <div class="span-4"><label>Staking 2 Total</label><input id="stkS2" type="number" step="0.00000001" value="2000"></div>
        <div class="span-4"><label>Staking 3 Total</label><input id="stkS3" type="number" step="0.00000001" value="30000"></div>
      </div>
    </div>

    <div class="card span-6">
      <h3>Parameters</h3>
      <div class="grid">
        <div class="span-4"><label>Per-Transfer Buffer (ETH)</label><input id="buf" type="number" step="0.00000001" value="0.01"></div>
        <div class="span-4"><label>Fee Min (ETH)</label><input id="feeMin" type="number" step="0.00000001" value="0.001"></div>
        <div class="span-4"><label>Fee Max (ETH)</label><input id="feeMax" type="number" step="0.00000001" value="0.01"></div>
      </div>
      <div class="row" style="margin-top:12px;">
        <button id="run" class="btn">Optimise Transfers</button>
        <span class="pill">Priority: <b>Validators</b> → <b>Transactions</b> → <b>Balance</b></span>
      </div>
    </div>

    <div id="output" class="span-12"></div>
  </div>

  <footer>No data leaves your browser. All calculations are client-side.</footer>
</div>

<!-- Loading overlay -->
<div id="loader" class="loader hidden" aria-hidden="true">
  <div class="spinner"></div>
  <p>Calculating optimal transfers…</p>
</div>

<script>
(function() {
  "use strict";

  // ------- Config / formatting -------
  const DEC_DESKTOP = 8;
  const DEC_MOBILE  = 6;
  const eps = 1e-9;

  const STAKING_NAMES = ["Staking 1", "Staking 2", "Staking 3"];

  const fmt = (x, dec) => {
    let s = Number(x).toFixed(dec);
    s = s.replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'');
    if (!s.includes(".")) s += ".00";
    return s;
  };
  const sum = (arr) => arr.reduce((a,b)=>a+b,0);

  const floorDiv32 = (x) => Math.floor(x / 32.0);
  const remainder32 = (x) => x - 32.0 * floorDiv32(x);

  function combinations(arr, k) {
    const res = [];
    function rec(start, comb) {
      if (comb.length === k) { res.push(comb.slice()); return; }
      for (let i=start; i<arr.length; i++) { comb.push(arr[i]); rec(i+1, comb); comb.pop(); }
    }
    rec(0, []);
    return res;
  }

  // ------- Core algorithm -------
  function chooseDestinations(payloadNeeded, stakingLiquid, stakingStaked) {
    const rema = stakingLiquid.map(remainder32);
    const topups = rema.map(r => (32.0 - r) % 32.0);
    const idxs = [0,1,2];
    let candidates = [];

    for (let size of [1,2,3]) {
      for (const subset of combinations(idxs, size)) {
        const base = subset.reduce((a,i)=>a+topups[i],0);
        if (payloadNeeded + eps >= base && Math.abs((payloadNeeded - base) % 32.0) < 1e-9) {
          const weight = subset.reduce((a,i)=>a+stakingStaked[i],0);
          candidates.push({subset, base, weight});
        }
      }
      if (candidates.length) break;
    }

    if (!candidates.length) {
      const j = stakingStaked.indexOf(Math.min(...stakingStaked));
      const payloads = [0,0,0]; payloads[j] = payloadNeeded;
      return { payloads, chosen: [j] };
    }

    candidates.sort((a,b)=>{
      if (a.subset.length !== b.subset.length) return a.subset.length - b.subset.length;
      return a.weight - b.weight;
    });
    const {subset, base} = candidates[0];

    const payloads = [0,0,0];
    subset.forEach(i => payloads[i] = topups[i]);
    const rest = payloadNeeded - base; // multiple of 32
    const jstar = subset.slice().sort((i,k)=>stakingStaked[i]-stakingStaked[k])[0];
    payloads[jstar] += rest;
    return { payloads, chosen: subset.slice() };
  }

  function assignSources(sources, staking, destPayloads, bufPerTx) {
    const transfers = [];
    const dests = destPayloads
      .map((p,i)=>({i, payload:p}))
      .filter(d=>d.payload > eps)
      .sort((a,b)=>b.payload - a.payload);

    const srcOrder = sources.map((_,i)=>i);
    const resort = () => srcOrder.sort((a,b)=>sources[b].end - sources[a].end);
    resort();

    for (const d of dests) {
      let need = d.payload;

      let one = srcOrder.find(si => sources[si].end >= (need + bufPerTx - eps));
      if (one !== undefined) {
        const total = need + bufPerTx;
        sources[one].end -= total; sources[one].sent += total;
        staking[d.i].end += total; staking[d.i].recvPayload += need; staking[d.i].recvBuffers += 1;
        transfers.push({src: sources[one].name, dst: staking[d.i].name, payload: need, total});
        resort();
        continue;
      }

      for (const si of srcOrder.slice()) {
        if (need <= eps) break;
        const capPayload = Math.max(0, sources[si].end - bufPerTx);
        if (capPayload <= eps) continue;
        const sendPayload = Math.min(capPayload, need);
        const total = sendPayload + bufPerTx;
        sources[si].end -= total; sources[si].sent += total;
        staking[d.i].end += total; staking[d.i].recvPayload += sendPayload; staking[d.i].recvBuffers += 1;
        transfers.push({src: sources[si].name, dst: staking[d.i].name, payload: sendPayload, total});
        need -= sendPayload;
        resort();
      }

      if (need > eps) throw new Error("Insufficient source liquidity for required payloads (after per-tx buffers).");
    }
    return transfers;
  }

  function plan(input) {
    const { src, stkLiquid, stkStaked, bufPerTx, feeMin, feeMax } = input;

    const sources = src.map((v,i)=>({ name:`Wallet ${i+1}`, start:v, end:v, sent:0 }));
    const staking = stkLiquid.map((v,i)=>({ name: ["Staking 1","Staking 2","Staking 3"][i], start:v, end:v, recvPayload:0, recvBuffers:0 }));

    const totalSources = sum(src);
    const totalLiquid = sum(stkLiquid);
    const theoreticalK = Math.floor((totalSources + totalLiquid) / 32.0);

    for (let k = theoreticalK; k >= 0; k--) {
      const payloadNeeded = Math.max(0, 32.0 * k - totalLiquid);

      let destPayloads = [0,0,0];
      if (payloadNeeded > eps) {
        const choice = chooseDestinations(payloadNeeded, stkLiquid, stkStaked);
        destPayloads = choice.payloads;
      }

      const simSources = sources.map(w=>({ ...w }));
      const simStaking = staking.map(w=>({ ...w }));
      let feasible = true;
      try { assignSources(simSources, simStaking, destPayloads, bufPerTx); }
      catch (e) { feasible = false; }

      if (feasible) {
        const transfers = assignSources(sources, staking, destPayloads, bufPerTx);

        const bufferRanges = staking.map(w => {
          const n = w.recvBuffers;
          const minLeft = Math.max(0, n * (bufPerTx - feeMax));
          const maxLeft = n * (bufPerTx - feeMin);
          return { name: w.name, n, minLeft, maxLeft };
        });

        return {
          k, sources, staking, transfers, destPayloads,
          totals: {
            totalPayloadAdded: sum(transfers.map(t=>t.payload)),
            totalBuffersSent: transfers.length * bufPerTx
          },
          bufferRanges,
          params: { bufPerTx, feeMin, feeMax }
        };
      }
    }
    throw new Error("No feasible plan found.");
  }

  // ------- UI -------
  function readInputs() {
    const val = id => parseFloat(document.getElementById(id).value || "0");
    return {
      src: [val("src1"), val("src2"), val("src3"), val("src4")],
      stkLiquid: [val("stkL1"), val("stkL2"), val("stkL3")],
      stkStaked: [val("stkS1"), val("stkS2"), val("stkS3")],
      bufPerTx: val("buf"),
      feeMin: val("feeMin"),
      feeMax: val("feeMax"),
    };
  }

  function render(result) {
    const out = document.getElementById("output");
    const mobile = window.matchMedia("(max-width: 820px)").matches;
    const DEC = mobile ? DEC_MOBILE : DEC_DESKTOP;

    const { k, transfers, sources, staking, totals, bufferRanges, params } = result;

    const transfersTable = `
      <div class="table-wrap">
        <table class="table">
          <thead><tr><th>#</th><th>From</th><th>To</th><th>Quantity (ETH)</th><th>Buffer (ETH)</th><th>Total Sent (ETH)</th></tr></thead>
          <tbody>
            ${transfers.map((t,i)=>`
              <tr>
                <td class="mono num">${i+1}</td>
                <td class="mono">${t.src}</td>
                <td class="mono">${t.dst}</td>
                <td class="mono num">${fmt(t.payload, DEC)}</td>
                <td class="mono num">${fmt(params.bufPerTx, DEC)}</td>
                <td class="mono num">${fmt(t.total, DEC)}</td>
              </tr>`).join("")}
          </tbody>
        </table>
      </div>`;

    const srcTable = `
      <div class="table-wrap">
        <table class="table">
          <thead><tr><th>Wallet</th><th>Before</th><th>After</th><th>Sent (Total)</th></tr></thead>
          <tbody>
            ${sources.map(w=>`
              <tr>
                <td class="mono">${w.name}</td>
                <td class="mono num">${fmt(w.start, DEC)}</td>
                <td class="mono num">${fmt(w.end, DEC)}</td>
                <td class="mono num">${fmt(w.sent, DEC)}</td>
              </tr>`).join("")}
          </tbody>
        </table>
      </div>`;

    const stkTable = `
      <div class="table-wrap">
        <table class="table">
          <thead>
            <tr>
              <th>Wallet</th>
              <th>Before</th>
              <th>After (pre-fee)</th>
              <th>Validators</th>
              <th>Remainder</th>
              <th class="nowrap">Incoming&nbsp;Tx</th>
            </tr>
          </thead>
          <tbody>
            ${staking.map(w=>{
              const before = w.start;
              const after = w.end;
              const vBefore = floorDiv32(before);
              const vAfter = floorDiv32(w.start + w.recvPayload);
              const rem = remainder32(w.start + w.recvPayload);
              return `
              <tr>
                <td class="mono">${w.name}</td>
                <td class="mono num">${fmt(before, DEC)}</td>
                <td class="mono num">${fmt(after, DEC)}</td>
                <td class="mono num">${vBefore} → ${vAfter}</td>
                <td class="mono num">${fmt(rem, DEC)}</td>
                <td class="mono num">${w.recvBuffers}</td>
              </tr>`;
            }).join("")}
          </tbody>
        </table>
      </div>`;

    const bufTable = `
      <div class="table-wrap">
        <table class="table">
          <thead><tr><th>Wallet</th><th class="nowrap">Incoming&nbsp;Tx</th><th>Min Remaining</th><th>Max Remaining</th></tr></thead>
          <tbody>
            ${bufferRanges.map(b=>`
              <tr>
                <td class="mono">${b.name}</td>
                <td class="mono num">${b.n}</td>
                <td class="mono num">${fmt(b.minLeft, DEC)}</td>
                <td class="mono num">${fmt(b.maxLeft, DEC)}</td>
              </tr>`).join("")}
          </tbody>
          <tfoot>
            <tr>
              <th>Total</th><th></th>
              <th class="mono num">${fmt(bufferRanges.reduce((a,b)=>a+b.minLeft,0), DEC)}</th>
              <th class="mono num">${fmt(bufferRanges.reduce((a,b)=>a+b.maxLeft,0), DEC)}</th>
            </tr>
          </tfoot>
        </table>
      </div>`;

    const summaryTable = `
      <div class="table-wrap">
        <table class="table">
          <tbody>
            <tr><td>Max validators achievable</td><td class="mono num">${k}</td></tr>
            <tr><td>Total quantity sent to staking wallets (stakeable)</td><td class="mono num">${fmt(totals.totalPayloadAdded, DEC)} ETH</td></tr>
            <tr><td>Total buffers sent (non-stakeable)</td><td class="mono num">${fmt(totals.totalBuffersSent, DEC)} ETH</td></tr>
            <tr><td>Total transfers</td><td class="mono num">${transfers.length}</td></tr>
            <tr><td>Priority respected</td><td class="mono">Validators → Transactions → Balance preference</td></tr>
          </tbody>
        </table>
      </div>`;

    const transfersCards = `
      <div class="cards">
        <div class="list">
          ${transfers.length ? transfers.map((t,i)=>`
            <div class="item">
              <h4>Transfer ${i+1}</h4>
              <div class="kv">
                <div class="k">From</div><div class="v mono">${t.src}</div>
                <div class="k">To</div><div class="v mono">${t.dst}</div>
                <div class="k">Payload</div><div class="v mono">${fmt(t.payload, DEC)} ETH</div>
                <div class="k">Buffer</div><div class="v mono">${fmt(result.params.bufPerTx, DEC)} ETH</div>
                <div class="k">Total Sent</div><div class="v mono">${fmt(t.total, DEC)} ETH</div>
              </div>
            </div>`).join("")
          : `<div class="item"><h4>No transfers required</h4><div class="subhead">Current liquidity already supports the maximum validator count.</div></div>`}
        </div>
      </div>`;

    const srcCards = `
      <div class="cards">
        <div class="list">
          ${sources.map(w=>`
            <div class="item">
              <h4>${w.name}</h4>
              <div class="kv">
                <div class="k">Before</div><div class="v mono">${fmt(w.start, DEC)}</div>
                <div class="k">After</div><div class="v mono">${fmt(w.end, DEC)}</div>
                <div class="k">Sent</div><div class="v mono">${fmt(w.sent, DEC)}</div>
              </div>
            </div>`).join("")}
        </div>
      </div>`;

    const stkCards = `
      <div class="cards">
        <div class="list">
          ${staking.map(w=>{
            const vBefore = floorDiv32(w.start);
            const vAfter = floorDiv32(w.start + w.recvPayload);
            const rem = remainder32(w.start + w.recvPayload);
            return `
              <div class="item">
                <h4>${w.name}</h4>
                <div class="kv">
                  <div class="k">Before</div><div class="v mono">${fmt(w.start, DEC)}</div>
                  <div class="k">After (pre-fee)</div><div class="v mono">${fmt(w.end, DEC)}</div>
                  <div class="k">Validators</div><div class="v mono">${vBefore} → ${vAfter}</div>
                  <div class="k">Remainder</div><div class="v mono">${fmt(rem, DEC)}</div>
                  <div class="k">Incoming Tx</div><div class="v mono">${w.recvBuffers}</div>
                </div>
              </div>`;
          }).join("")}
        </div>
      </div>`;

    const bufCards = `
      <div class="cards">
        <div class="list">
          ${bufferRanges.map(b=>`
            <div class="item">
              <h4>${b.name}</h4>
              <div class="kv">
                <div class="k">Incoming Tx</div><div class="v mono">${b.n}</div>
                <div class="k">Min Remaining</div><div class="v mono">${fmt(b.minLeft, DEC)} ETH</div>
                <div class="k">Max Remaining</div><div class="v mono">${fmt(b.maxLeft, DEC)} ETH</div>
              </div>
            </div>`).join("")}
          <div class="item">
            <h4>Total Buffers After Fees</h4>
            <div class="kv">
              <div class="k">Min Total</div><div class="v mono">${fmt(bufferRanges.reduce((a,b)=>a+b.minLeft,0), DEC)} ETH</div>
              <div class="k">Max Total</div><div class="v mono">${fmt(bufferRanges.reduce((a,b)=>a+b.maxLeft,0), DEC)} ETH</div>
            </div>
          </div>
        </div>
      </div>`;

    const summaryCards = `
      <div class="cards">
        <div class="list">
          <div class="item">
            <h4>Summary</h4>
            <div class="kv">
              <div class="k">Max Validators</div><div class="v mono">${k}</div>
              <div class="k">Payload Added</div><div class="v mono">${fmt(totals.totalPayloadAdded, DEC)} ETH</div>
              <div class="k">Buffers Sent</div><div class="v mono">${fmt(totals.totalBuffersSent, DEC)} ETH</div>
              <div class="k">Transfers</div><div class="v mono">${transfers.length}</div>
              <div class="k">Priority</div><div class="v mono">Validators → Tx → Balance</div>
            </div>
          </div>
        </div>
      </div>`;

    out.innerHTML = `
      <div class="card">
        <h3>Optimal Transfers</h3>
        <div class="table-wrap">${transfersTable}</div>
        ${transfersCards}
      </div>

      <div class="grid" style="margin-top:12px;">
        <div class="card span-6">
          <h3>Source Wallets — Balances (Before → After)</h3>
          <div class="table-wrap">${srcTable}</div>
          ${srcCards}
        </div>

        <div class="card span-6">
          <h3>Staking Wallets — Liquid (Before → After, pre-fee)</h3>
          <div class="table-wrap">${stkTable}</div>
          ${stkCards}
        </div>
      </div>
      <div class="grid" style="margin-top:12px;">
        <div class="card span-6">
          <h3>Buffer Remainders After Fees</h3>
          <div class="muted">Using per-transfer fee range; set in Parameters.</div>
          <div class="table-wrap">${bufTable}</div>
          ${bufCards}
        </div>

        <div class="card span-6">
          <h3>Summary</h3>
          <div class="table-wrap">${summaryTable}</div>
          ${summaryCards}
        </div>
      </div>
    `;
  }

  // ------- Loader helpers -------
  const loaderEl = document.getElementById("loader");
  function showLoader() {
    loaderEl.classList.remove("hidden");
    loaderEl.setAttribute("aria-hidden", "false");
  }
  function hideLoader() {
    loaderEl.classList.add("hidden");
    loaderEl.setAttribute("aria-hidden", "true");
  }

  function runPlannerCore() {
    const inp = readInputs();
    if (inp.feeMax < inp.feeMin) throw new Error("Fee Max must be ≥ Fee Min.");
    const res = plan(inp);
    render(res);
  }

  function runPlannerWithLoader() {
    showLoader();
    requestAnimationFrame(() => {
      setTimeout(() => {
        try { runPlannerCore(); }
        catch (e) {
          document.getElementById("output").innerHTML = `<div class="card"><h3>Oops</h3><p>${e.message}</p></div>`;
        } finally {
          setTimeout(hideLoader, 1000); // 1000ms spinner
        }
      }, 0);
    });
  }

  document.getElementById("run").addEventListener("click", runPlannerWithLoader);
  window.addEventListener("resize", runPlannerCore);
  runPlannerCore();
})();
</script>
</body>
</html>
