<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>ETH Staking Transfer Planner</title>
<style>
  :root { --bg:#0b0c10; --card:#121319; --muted:#7f8c99; --fg:#e8ecf1; --accent:#5ad6a3; --border:#232632; }

  /* Base */
  body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
  .container { max-width: 1100px; margin: 32px auto; padding: 0 16px; }
  h1 { font-size: 24px; margin: 0 0 16px; }
  h3 { margin: 0 0 12px; }
  p.desc { color: var(--muted); margin-top: 0; }
  .grid { display: grid; gap: 12px; grid-template-columns: repeat(12, 1fr); }
  .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 16px; }
  .span-12 { grid-column: span 12; }
  .span-6 { grid-column: span 6; }
  .span-4 { grid-column: span 4; }
  .span-3 { grid-column: span 3; }
  .span-2 { grid-column: span 2; }

  label { display:block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
  input { width:100%; padding:12px 14px; border-radius:10px; border:1px solid var(--border); background:#0f1016; color:var(--fg); }
  .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .btn { appearance: none; background: var(--accent); color:#042318; border:none; border-radius: 12px; padding: 12px 16px; font-weight: 700; cursor: pointer; }
  .btn:disabled { opacity:.6; cursor:not-allowed; }
  .pill { display:inline-block; background:#0f1016; border:1px solid var(--border); padding:6px 10px; border-radius:999px; font-size:12px; color:var(--muted); }
  .muted { color: var(--muted); }

  /* Desktop tables */
  .table { width:100%; border-collapse: collapse; font-size: 13px; }
  .table th, .table td { padding: 12px 14px; border-bottom: 1px solid var(--border); text-align: left; vertical-align: top; }
  .table th { color: var(--muted); font-weight:600; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-variant-numeric: tabular-nums; -webkit-font-feature-settings: "tnum" 1, "lnum" 1; font-feature-settings: "tnum" 1, "lnum" 1; white-space: nowrap; }
  .num { text-align: right; }

  /* Mobile “cards” — no horizontal scroll */
  .list { display: grid; grid-template-columns: 1fr; gap: 10px; }
  .item { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 12px; }
  .item h4 { margin: 0 0 6px; font-size: 14px; }
  .kv { display:grid; grid-template-columns: auto 1fr; gap: 6px 10px; }
  .kv div { padding: 4px 0; }
  .k { color: var(--muted); }
  .v { text-align: right; }
  .v .mono { white-space: nowrap; }

  /* Section header spacing inside cards */
  .subhead { margin: 10px 0 6px; color: var(--muted); font-size: 12px; }

  footer { margin: 24px 0; color: var(--muted); font-size: 12px; }

  /* Responsive: stack inputs on mobile */
  @media (max-width: 900px) {
    .span-6, .span-4, .span-3, .span-2 { grid-column: span 12; }
  }

  /* Kill tables on small screens; use cards instead */
  @media (max-width: 820px) {
    .table-wrap { display:none; } /* hide tables entirely */
  }
  /* On bigger screens show tables and hide mobile cards */
  @media (min-width: 821px) {
    .cards { display:none; }
  }

  /* Slightly smaller type in very tight spaces (iPhone landscape is ~736–812px CSS px) */
  @media (max-width: 820px) {
    body { font-size: 15px; }
    h1 { font-size: 20px; }
    .item { padding: 12px; }
    .kv { gap: 4px 8px; }
  }
</style>
</head>
<body>
<div class="container">
  <h1>ETH Staking Transfer Planner</h1>
  <p class="desc">Enter 4 source wallet <b>liquid</b> balances, 3 staking wallet <b>liquid</b> balances, and 3 staking wallet <b>staked totals</b>. The planner maximizes validators, minimizes transactions, and prefers topping up the lowest-staked wallet. Each transfer carries a buffer and we show min/max leftover buffers after fees.</p>

  <div class="grid">
    <div class="card span-6">
      <h3>Source Wallets (4)</h3>
      <div class="grid">
        <div class="span-3"><label>Wallet 1</label><input id="src1" type="number" step="0.00000001" value="10"></div>
        <div class="span-3"><label>Wallet 2</label><input id="src2" type="number" step="0.00000001" value="50"></div>
        <div class="span-3"><label>Wallet 3</label><input id="src3" type="number" step="0.00000001" value="20"></div>
        <div class="span-3"><label>Wallet 4</label><input id="src4" type="number" step="0.00000001" value="1"></div>
      </div>
    </div>

    <div class="card span-6">
      <h3>Staking Wallets (3) — Liquid</h3>
      <div class="grid">
        <div class="span-4"><label>Staking 1 Liquid</label><input id="stkL1" type="number" step="0.00000001" value="20"></div>
        <div class="span-4"><label>Staking 2 Liquid</label><input id="stkL2" type="number" step="0.00000001" value="31"></div>
        <div class="span-4"><label>Staking 3 Liquid</label><input id="stkL3" type="number" step="0.00000001" value="40"></div>
      </div>
    </div>

    <div class="card span-6">
      <h3>Staking Wallets (3) — Staked Totals (balancing)</h3>
      <div class="grid">
        <div class="span-4"><label>Staking 1 Staked</label><input id="stkS1" type="number" step="0.00000001" value="10000"></div>
        <div class="span-4"><label>Staking 2 Staked</label><input id="stkS2" type="number" step="0.00000001" value="2000"></div>
        <div class="span-4"><label>Staking 3 Staked</label><input id="stkS3" type="number" step="0.00000001" value="30000"></div>
      </div>
    </div>

    <div class="card span-6">
      <h3>Parameters</h3>
      <div class="grid">
        <div class="span-4"><label>Per-Transfer Buffer (ETH)</label><input id="buf" type="number" step="0.00000001" value="0.01"></div>
        <div class="span-4"><label>Fee Min (ETH)</label><input id="feeMin" type="number" step="0.00000001" value="0.001"></div>
        <div class="span-4"><label>Fee Max (ETH)</label><input id="feeMax" type="number" step="0.00000001" value="0.01"></div>
      </div>
      <div class="row" style="margin-top:12px;">
        <button id="run" class="btn">Plan Transfers</button>
        <span class="pill">Priority: <b>Validators</b> → <b>Transactions</b> → <b>Balance</b></span>
      </div>
    </div>

    <div id="output" class="span-12"></div>
  </div>

  <footer>No data leaves your browser. All calculations are client-side.</footer>
</div>

<script>
(function() {
  "use strict";

  // ------- Config / formatting -------
  const DEC_DESKTOP = 8;
  const DEC_MOBILE  = 6; // fewer decimals on phones to keep lines single-row
  const eps = 1e-9;
  const isMobileLike = () => window.matchMedia("(max-width: 820px)").matches;

  const fmt = (x, dec) => {
    // fixed decimals then trim trailing zeros (keeps at least 2 decimals)
    let s = Number(x).toFixed(dec);
    s = s.replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'');
    if (!s.includes(".")) s += ".00";
    return s;
  };
  const sum = (arr) => arr.reduce((a,b)=>a+b,0);

  const floorDiv32 = (x) => Math.floor(x / 32.0);
  const remainder32 = (x) => x - 32.0 * floorDiv32(x);

  function combinations(arr, k) {
    const res = [];
    function rec(start, comb) {
      if (comb.length === k) { res.push(comb.slice()); return; }
      for (let i=start; i<arr.length; i++) {
        comb.push(arr[i]);
        rec(i+1, comb);
        comb.pop();
      }
    }
    rec(0, []);
    return res;
  }

  // ------- Core algorithm (same logic as before) -------
  function chooseDestinations(payloadNeeded, stakingLiquid, stakingStaked) {
    const rema = stakingLiquid.map(remainder32);
    const topups = rema.map(r => (32.0 - r) % 32.0);
    const idxs = [0,1,2];
    let candidates = [];

    for (let size of [1,2,3]) {
      for (const subset of combinations(idxs, size)) {
        const base = subset.reduce((a,i)=>a+topups[i],0);
        if (payloadNeeded + eps >= base && Math.abs((payloadNeeded - base) % 32.0) < 1e-9) {
          const weight = subset.reduce((a,i)=>a+stakingStaked[i],0); // lower is better
          candidates.push({subset, base, weight});
        }
      }
      if (candidates.length) break;
    }

    if (!candidates.length) {
      const j = stakingStaked.indexOf(Math.min(...stakingStaked));
      const payloads = [0,0,0];
      payloads[j] = payloadNeeded;
      return { payloads, chosen: [j] };
    }

    candidates.sort((a,b)=>{
      if (a.subset.length !== b.subset.length) return a.subset.length - b.subset.length;
      return a.weight - b.weight;
    });
    const {subset, base} = candidates[0];

    const payloads = [0,0,0];
    subset.forEach(i => payloads[i] = topups[i]);
    const rest = payloadNeeded - base; // multiple of 32
    const jstar = subset.slice().sort((i,k)=>stakingStaked[i]-stakingStaked[k])[0];
    payloads[jstar] += rest;
    return { payloads, chosen: subset.slice() };
  }

  function assignSources(sources, staking, destPayloads, bufPerTx) {
    const transfers = [];
    const dests = destPayloads
      .map((p,i)=>({i, payload:p}))
      .filter(d=>d.payload > eps)
      .sort((a,b)=>b.payload - a.payload);

    const srcOrder = sources.map((_,i)=>i);
    const resort = () => srcOrder.sort((a,b)=>sources[b].end - sources[a].end);
    resort();

    for (const d of dests) {
      let need = d.payload;

      // Try one-shot source
      let one = srcOrder.find(si => sources[si].end >= (need + bufPerTx - eps));
      if (one !== undefined) {
        const total = need + bufPerTx;
        sources[one].end -= total; sources[one].sent += total;
        staking[d.i].end += total; staking[d.i].recvPayload += need; staking[d.i].recvBuffers += 1;
        transfers.push({src: sources[one].name, dst: staking[d.i].name, payload: need, total});
        resort();
        continue;
      }

      // Split across sources
      for (const si of srcOrder.slice()) {
        if (need <= eps) break;
        const capPayload = Math.max(0, sources[si].end - bufPerTx);
        if (capPayload <= eps) continue;
        const sendPayload = Math.min(capPayload, need);
        const total = sendPayload + bufPerTx;
        sources[si].end -= total; sources[si].sent += total;
        staking[d.i].end += total; staking[d.i].recvPayload += sendPayload; staking[d.i].recvBuffers += 1;
        transfers.push({src: sources[si].name, dst: staking[d.i].name, payload: sendPayload, total});
        need -= sendPayload;
        resort();
      }

      if (need > eps) throw new Error("Insufficient source liquidity for required payloads (after per-tx buffers).");
    }

    return transfers;
  }

  function plan(input) {
    const { src, stkLiquid, stkStaked, bufPerTx, feeMin, feeMax } = input;

    const sources = src.map((v,i)=>({ name:`Wallet ${i+1}`, start:v, end:v, sent:0 }));
    const staking = stkLiquid.map((v,i)=>({ name:`Staking ${i+1}`, start:v, end:v, recvPayload:0, recvBuffers:0 }));

    const totalSources = sum(src);
    const totalLiquid = sum(stkLiquid);
    const theoreticalK = Math.floor((totalSources + totalLiquid) / 32.0);

    for (let k = theoreticalK; k >= 0; k--) {
      const payloadNeeded = Math.max(0, 32.0 * k - totalLiquid);

      let destPayloads = [0,0,0];
      if (payloadNeeded > eps) {
        const choice = chooseDestinations(payloadNeeded, stkLiquid, stkStaked);
        destPayloads = choice.payloads;
      }

      // Simulate feasibility
      const simSources = sources.map(w=>({ ...w }));
      const simStaking = staking.map(w=>({ ...w }));
      let feasible = true;
      try {
        assignSources(simSources, simStaking, destPayloads, bufPerTx);
      } catch (e) { feasible = false; }

      if (feasible) {
        const transfers = assignSources(sources, staking, destPayloads, bufPerTx);

        const bufferRanges = staking.map(w => {
          const n = w.recvBuffers;
          const minLeft = Math.max(0, n * (bufPerTx - feeMax));
          const maxLeft = n * (bufPerTx - feeMin);
          return { name: w.name, n, minLeft, maxLeft };
        });

        return {
          k, sources, staking, transfers, destPayloads,
          totals: {
            totalPayloadAdded: sum(transfers.map(t=>t.payload)),
            totalBuffersSent: transfers.length * bufPerTx
          },
          bufferRanges,
          params: { bufPerTx, feeMin, feeMax }
        };
      }
    }
    throw new Error("No feasible plan found.");
  }

  // ------- UI -------
  function readInputs() {
    const val = id => parseFloat(document.getElementById(id).value || "0");
    return {
      src: [val("src1"), val("src2"), val("src3"), val("src4")],
      stkLiquid: [val("stkL1"), val("stkL2"), val("stkL3")],
      stkStaked: [val("stkS1"), val("stkS2"), val("stkS3")],
      bufPerTx: val("buf"),
      feeMin: val("feeMin"),
      feeMax: val("feeMax"),
    };
  }

  function render(result) {
    const out = document.getElementById("output");
    const mobile = isMobileLike();
    const DEC = mobile ? DEC_MOBILE : DEC_DESKTOP;

    const { k, transfers, sources, staking, totals, bufferRanges, params } = result;

    // --- Desktop tables ---
    const transfersTable = `
      <div class="table-wrap">
        <table class="table">
          <thead><tr><th>#</th><th>From</th><th>To</th><th>Payload (ETH)</th><th>Buffer (ETH)</th><th>Total Sent (ETH)</th></tr></thead>
          <tbody>
            ${transfers.map((t,i)=>`
              <tr>
                <td class="mono num">${i+1}</td>
                <td class="mono">${t.src}</td>
                <td class="mono">${t.dst}</td>
                <td class="mono num">${fmt(t.payload, DEC)}</td>
                <td class="mono num">${fmt(params.bufPerTx, DEC)}</td>
                <td class="mono num">${fmt(t.total, DEC)}</td>
              </tr>`).join("")}
          </tbody>
        </table>
      </div>`;

    const srcTable = `
      <div class="table-wrap">
        <table class="table">
          <thead><tr><th>Wallet</th><th>Before</th><th>After</th><th>Sent (Total)</th></tr></thead>
          <tbody>
            ${sources.map(w=>`
              <tr>
                <td class="mono">${w.name}</td>
                <td class="mono num">${fmt(w.start, DEC)}</td>
                <td class="mono num">${fmt(w.end, DEC)}</td>
                <td class="mono num">${fmt(w.sent, DEC)}</td>
              </tr>`).
