<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ETH Staking Transfer Planner</title>
<style>
  :root { --bg:#0b0c10; --card:#121319; --muted:#7f8c99; --fg:#e8ecf1; --accent:#5ad6a3; --border:#232632; }
  body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--fg); }
  .container { max-width: 1100px; margin: 32px auto; padding: 0 16px; }
  h1 { font-size: 24px; margin: 0 0 16px; }
  p.desc { color: var(--muted); margin-top: 0; }
  .grid { display: grid; gap: 12px; grid-template-columns: repeat(12, 1fr); }
  .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 16px; }
  .span-12 { grid-column: span 12; }
  .span-6 { grid-column: span 6; }
  .span-4 { grid-column: span 4; }
  .span-3 { grid-column: span 3; }
  .span-2 { grid-column: span 2; }
  label { display:block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
  input { width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--border); background:#0f1016; color:var(--fg); }
  .row { display:flex; gap:12px; align-items: center; flex-wrap: wrap; }
  .btn { appearance: none; background: var(--accent); color:#042318; border:none; border-radius: 12px; padding: 12px 16px; font-weight: 700; cursor: pointer; }
  .btn:disabled { opacity:.6; cursor:not-allowed; }
  table { width:100%; border-collapse: collapse; font-size: 13px; }
  th, td { padding: 8px 10px; border-bottom: 1px solid var(--border); text-align: left; }
  th { color: var(--muted); font-weight:600; }
  .muted { color: var(--muted); }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  .pill { display:inline-block; background:#0f1016; border:1px solid var(--border); padding:4px 8px; border-radius:999px; font-size:12px; color:var(--muted); }
  .ok { color: var(--accent); }
  details { border:1px solid var(--border); border-radius: 12px; padding: 10px 12px; }
  summary { cursor:pointer; color: var(--muted); }
  footer { margin: 24px 0; color: var(--muted); font-size: 12px; }
  @media (max-width: 900px) { .span-6 { grid-column: span 12; } .span-4 { grid-column: span 12; } .span-3 { grid-column: span 6; } .span-2 { grid-column: span 6; } }
</style>
</head>
<body>
<div class="container">
  <h1>ETH Staking Transfer Planner</h1>
  <p class="desc">Enter 4 source wallet liquid balances, 3 staking wallet <b>liquid</b> balances, and 3 staking wallet <b>staked totals</b>. The planner maximizes validators, minimizes transactions, and prefers topping up the lowest-staked wallet. Each transfer carries a buffer for fees and reports min/max leftover buffer ranges.</p>

  <div class="grid">
    <div class="card span-6">
      <h3>Source Wallets (4)</h3>
      <div class="grid">
        <div class="span-3"><label>Wallet 1</label><input id="src1" type="number" step="0.00000001" value="10"></div>
        <div class="span-3"><label>Wallet 2</label><input id="src2" type="number" step="0.00000001" value="50"></div>
        <div class="span-3"><label>Wallet 3</label><input id="src3" type="number" step="0.00000001" value="20"></div>
        <div class="span-3"><label>Wallet 4</label><input id="src4" type="number" step="0.00000001" value="1"></div>
      </div>
    </div>

    <div class="card span-6">
      <h3>Staking Wallets (3) — Liquid</h3>
      <div class="grid">
        <div class="span-4"><label>Staking 1 Liquid</label><input id="stkL1" type="number" step="0.00000001" value="20"></div>
        <div class="span-4"><label>Staking 2 Liquid</label><input id="stkL2" type="number" step="0.00000001" value="31"></div>
        <div class="span-4"><label>Staking 3 Liquid</label><input id="stkL3" type="number" step="0.00000001" value="40"></div>
      </div>
    </div>

    <div class="card span-6">
      <h3>Staking Wallets (3) — Staked Totals (for balancing preference)</h3>
      <div class="grid">
        <div class="span-4"><label>Staking 1 Staked</label><input id="stkS1" type="number" step="0.00000001" value="10000"></div>
        <div class="span-4"><label>Staking 2 Staked</label><input id="stkS2" type="number" step="0.00000001" value="2000"></div>
        <div class="span-4"><label>Staking 3 Staked</label><input id="stkS3" type="number" step="0.00000001" value="30000"></div>
      </div>
    </div>

    <div class="card span-6">
      <h3>Parameters</h3>
      <div class="grid">
        <div class="span-4"><label>Per-Transfer Buffer (ETH)</label><input id="buf" type="number" step="0.00000001" value="0.01"></div>
        <div class="span-4"><label>Fee Min (ETH)</label><input id="feeMin" type="number" step="0.00000001" value="0.001"></div>
        <div class="span-4"><label>Fee Max (ETH)</label><input id="feeMax" type="number" step="0.00000001" value="0.01"></div>
      </div>
      <div class="row" style="margin-top:12px;">
        <button id="run" class="btn">Plan Transfers</button>
        <span class="pill">Priority: <b>Validators</b> → <b>Transactions</b> → <b>Balance Pref</b></span>
      </div>
    </div>

    <div id="output" class="span-12"></div>
  </div>

  <footer>No data leaves your browser. All calculations are client-side.</footer>
</div>

<script>
(function() {
  "use strict";

  // ---------- Utils ----------
  const DEC = 8;
  const eps = 1e-9;
  const fmt = (x) => Number(x).toFixed(DEC);
  const sum = (arr) => arr.reduce((a,b)=>a+b,0);

  const floorDiv32 = (x) => Math.floor(x / 32.0);
  const remainder32 = (x) => x - 32.0 * floorDiv32(x);

  function combinations(arr, k) {
    const res = [];
    function rec(start, comb) {
      if (comb.length === k) { res.push(comb.slice()); return; }
      for (let i=start; i<arr.length; i++) {
        comb.push(arr[i]);
        rec(i+1, comb);
        comb.pop();
      }
    }
    rec(0, []);
    return res;
  }

  // ---------- Core algorithm ----------
  function chooseDestinations(payloadNeeded, stakingLiquid, stakingStaked) {
    const rema = stakingLiquid.map(remainder32);
    const topups = rema.map(r => (32.0 - r) % 32.0);
    const idxs = [0,1,2];
    let candidates = [];

    for (let size of [1,2,3]) {
      for (const subset of combinations(idxs, size)) {
        const base = subset.reduce((a,i)=>a+topups[i],0);
        if (payloadNeeded + eps >= base && Math.abs((payloadNeeded - base) % 32.0) < 1e-9) {
          const weight = subset.reduce((a,i)=>a+stakingStaked[i],0); // lower is better
          candidates.push({subset, base, weight});
        }
      }
      if (candidates.length) break; // minimal destinations found
    }

    if (!candidates.length) {
      // Fallback: send everything to lowest-staked wallet
      const j = stakingStaked.indexOf(Math.min(...stakingStaked));
      const payloads = [0,0,0];
      payloads[j] = payloadNeeded;
      return { payloads, chosen: [j] };
    }

    // Pick smallest size; then smallest weight (favor low staked)
    candidates.sort((a,b)=>{
      if (a.subset.length !== b.subset.length) return a.subset.length - b.subset.length;
      return a.weight - b.weight;
    });
    const {subset, base} = candidates[0];

    const payloads = [0,0,0];
    subset.forEach(i => payloads[i] = topups[i]);
    const rest = payloadNeeded - base; // multiple of 32
    const jstar = subset.slice().sort((i,k)=>stakingStaked[i]-stakingStaked[k])[0];
    payloads[jstar] += rest;
    return { payloads, chosen: subset.slice() };
  }

  function assignSources(sources, staking, destPayloads, bufPerTx) {
    // sources/staking are objects with {name, start, end, sent, recvPayload, recvBuffers}
    const transfers = [];
    const dests = destPayloads
      .map((p,i)=>({i, payload:p}))
      .filter(d=>d.payload > eps)
      .sort((a,b)=>b.payload - a.payload);

    // order sources by descending end balance
    const srcOrder = sources.map((_,i)=>i);

    const resort = () => srcOrder.sort((a,b)=>sources[b].end - sources[a].end);

    resort();

    for (const d of dests) {
      let need = d.payload;

      // Try one-shot source
      let one = srcOrder.find(si => sources[si].end >= (need + bufPerTx - eps));
      if (one !== undefined) {
        const total = need + bufPerTx;
        sources[one].end -= total; sources[one].sent += total;
        staking[d.i].end += total; staking[d.i].recvPayload += need; staking[d.i].recvBuffers += 1;
        transfers.push({src: sources[one].name, dst: staking[d.i].name, payload: need, total});
        resort();
        continue;
      }

      // Split across sources
      for (const si of srcOrder.slice()) {
        if (need <= eps) break;
        const capPayload = Math.max(0, sources[si].end - bufPerTx);
        if (capPayload <= eps) continue;
        const sendPayload = Math.min(capPayload, need);
        const total = sendPayload + bufPerTx;
        sources[si].end -= total; sources[si].sent += total;
        staking[d.i].end += total; staking[d.i].recvPayload += sendPayload; staking[d.i].recvBuffers += 1;
        transfers.push({src: sources[si].name, dst: staking[d.i].name, payload: sendPayload, total});
        need -= sendPayload;
        resort();
      }

      if (need > eps) throw new Error("Insufficient source liquidity for required payloads (after per-tx buffers).");
    }

    return transfers;
  }

  function plan(input) {
    const { src, stkLiquid, stkStaked, bufPerTx, feeMin, feeMax } = input;

    const sources = src.map((v,i)=>({ name:`Wallet ${i+1}`, start:v, end:v, sent:0 }));
    const staking = stkLiquid.map((v,i)=>({ name:`Staking ${i+1}`, start:v, end:v, recvPayload:0, recvBuffers:0 }));

    const totalSources = sum(src);
    const totalLiquid = sum(stkLiquid);
    const theoreticalK = Math.floor((totalSources + totalLiquid) / 32.0);

    // Try from theoretical k downwards until feasible with buffers
    for (let k = theoreticalK; k >= 0; k--) {
      const payloadNeeded = Math.max(0, 32.0 * k - totalLiquid);

      let destPayloads = [0,0,0];
      if (payloadNeeded > eps) {
        const choice = chooseDestinations(payloadNeeded, stkLiquid, stkStaked);
        destPayloads = choice.payloads;
      }

      // Simulate to check feasibility with buffers
      const simSources = sources.map(w=>({ ...w }));
      const simStaking = staking.map(w=>({ ...w }));
      let feasible = true, simTransfers = [];
      try {
        simTransfers = assignSources(simSources, simStaking, destPayloads, bufPerTx);
      } catch (e) {
        feasible = false;
      }

      if (feasible) {
        // Commit
        const transfers = assignSources(sources, staking, destPayloads, bufPerTx);

        // Buffer leftovers (after fees) per staking wallet
        const bufferRanges = staking.map(w => {
          const n = w.recvBuffers;
          const minLeft = Math.max(0, n * (bufPerTx - feeMax));
          const maxLeft = n * (bufPerTx - feeMin);
          return { name: w.name, n, minLeft, maxLeft };
        });

        return {
          k,
          sources,
          staking,
          transfers,
          destPayloads,
          totals: {
            totalPayloadAdded: sum(transfers.map(t=>t.payload)),
            totalBuffersSent: transfers.length * bufPerTx
          },
          bufferRanges,
          params: { bufPerTx, feeMin, feeMax }
        };
      }
    }

    throw new Error("No feasible plan found.");
  }

  // ---------- UI glue ----------
  function readInputs() {
    const val = id => parseFloat(document.getElementById(id).value || "0");
    return {
      src: [val("src1"), val("src2"), val("src3"), val("src4")],
      stkLiquid: [val("stkL1"), val("stkL2"), val("stkL3")],
      stkStaked: [val("stkS1"), val("stkS2"), val("stkS3")],
      bufPerTx: val("buf"),
      feeMin: val("feeMin"),
      feeMax: val("feeMax"),
    };
  }

  function render(result) {
    const out = document.getElementById("output");
    const { k, transfers, sources, staking, totals, bufferRanges, params } = result;

    const transfersHtml = transfers.length
      ? `
        <table>
          <thead><tr><th>#</th><th>From</th><th>To</th><th>Payload (ETH)</th><th>Buffer (ETH)</th><th>Total Sent (ETH)</th></tr></thead>
          <tbody>
            ${transfers.map((t,i)=>`
              <tr>
                <td>${i+1}</td>
                <td class="mono">${t.src}</td>
                <td class="mono">${t.dst}</td>
                <td class="mono">${fmt(t.payload)}</td>
                <td class="mono">${fmt(params.bufPerTx)}</td>
                <td class="mono">${fmt(t.total)}</td>
              </tr>`).join("")}
          </tbody>
        </table>`
      : `<p class="muted">No transfers required. Current liquidity already supports the maximum validator count.</p>`;

    const srcRows = sources.map(w=>`
      <tr>
        <td class="mono">${w.name}</td>
        <td class="mono">${fmt(w.start)}</td>
        <td class="mono">${fmt(w.end)}</td>
        <td class="mono">${fmt(w.sent)}</td>
      </tr>`).join("");

    const stkRows = staking.map(w=>{
      const before = w.start;
      const after = w.end; // pre-fee
      const vBefore = floorDiv32(before);
      const vAfter = floorDiv32(w.start + w.recvPayload); // stakeable liquid
      const rem = remainder32(w.start + w.recvPayload);
      return `
      <tr>
        <td class="mono">${w.name}</td>
        <td class="mono">${fmt(before)}</td>
        <td class="mono">${fmt(after)}</td>
        <td class="mono">${vBefore} → ${vAfter}</td>
        <td class="mono">${fmt(rem)}</td>
        <td class="mono">${w.recvBuffers}</td>
      </tr>`;
    }).join("");

    const bufRows = bufferRanges.map(b=>`
      <tr>
        <td class="mono">${b.name}</td>
        <td class="mono">${b.n}</td>
        <td class="mono">${fmt(b.minLeft)}</td>
        <td class="mono">${fmt(b.maxLeft)}</td>
      </tr>`).join("");

    const totalMin = bufferRanges.reduce((a,b)=>a+b.minLeft,0);
    const totalMax = bufferRanges.reduce((a,b)=>a+b.maxLeft,0);

    out.innerHTML = `
      <div class="card">
        <h3>Transfer Plan</h3>
        ${transfersHtml}
      </div>

      <div class="grid" style="margin-top:12px;">
        <div class="card span-6">
          <h3>Source Wallets — Balances (Before → After)</h3>
          <table>
            <thead><tr><th>Wallet</th><th>Before</th><th>After</th><th>Sent (Total)</th></tr></thead>
            <tbody>${srcRows}</tbody>
          </table>
        </div>

        <div class="card span-6">
          <h3>Staking Wallets — Liquid (Before → After, pre-fee)</h3>
          <table>
            <thead><tr><th>Wallet</th><th>Before</th><th>After (pre-fee)</th><th>Validators</th><th>Remainder</th><th>Incoming Tx</th></tr></thead>
            <tbody>${stkRows}</tbody>
          </table>
        </div>
      </div>

      <div class="grid" style="margin-top:12px;">
        <div class="card span-6">
          <h3>Buffer Remainders After Fees</h3>
          <p class="muted">Assuming per-transfer fee ∈ [${fmt(params.feeMin)}, ${fmt(params.feeMax)}] ETH</p>
          <table>
            <thead><tr><th>Wallet</th><th># Incoming Tx</th><th>Min Remaining</th><th>Max Remaining</th></tr></thead>
            <tbody>${bufRows}</tbody>
            <tfoot>
              <tr>
                <th>Total</th><th></th>
                <th class="mono">${fmt(totalMin)}</th>
                <th class="mono">${fmt(totalMax)}</th>
              </tr>
            </tfoot>
          </table>
        </div>

        <div class="card span-6">
          <h3>Summary</h3>
          <table>
            <tbody>
              <tr><td>Max validators achievable</td><td class="mono">${k}</td></tr>
              <tr><td>Total payload added to staking (stakeable)</td><td class="mono">${fmt(totals.totalPayloadAdded)} ETH</td></tr>
              <tr><td>Total buffers sent (non-stakeable)</td><td class="mono">${fmt(totals.totalBuffersSent)} ETH</td></tr>
              <tr><td>Total transfers</td><td class="mono">${transfers.length}</td></tr>
              <tr><td>Priority respected</td><td class="mono">Validators → Transactions → Balance preference</td></tr>
            </tbody>
          </table>
          <details style="margin-top:10px;">
            <summary>Notes</summary>
            <ul>
              <li>Each transfer sends <b>payload + buffer</b>. Only payload is stakeable.</li>
              <li>Validator math uses <b>liquid</b> only. Buffers are for fees and may leave small remainders.</li>
              <li>Minimize transactions: the planner tries to use one source per destination; splits only if unavoidable.</li>
              <li>Balance preference: among equally optimal plans, the lowest-staked wallet is favored.</li>
            </ul>
          </details>
        </div>
      </div>
    `;
  }

  // Wire up
  document.getElementById("run").addEventListener("click", () => {
    try {
      const inp = readInputs();
      if (inp.feeMax < inp.feeMin) throw new Error("Fee Max must be ≥ Fee Min.");
      const res = plan(inp);
      render(res);
    } catch (e) {
      const out = document.getElementById("output");
      out.innerHTML = `<div class="card"><h3>Oops</h3><p>${e.message}</p></div>`;
    }
  });

  // Auto-run once with defaults
  document.getElementById("run").click();
})();
</script>
</body>
</html>
